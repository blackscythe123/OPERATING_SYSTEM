#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;

int isInMemory(int memory[], int frames, int page) {
    for (int j = 0; j &lt; frames; j++) {
        if (memory[j] == page) {
            return j;
        }
    }
    return -1;
}

int optimalPage(int ref[], int n, int frames) {
    int *memory = (int *)malloc(frames * sizeof(int));
    memset(memory, -1, frames * sizeof(int));
    int faults = 0;

    for (int i = 0; i &lt; n; i++) {
        int page = ref[i];
        int pos = isInMemory(memory, frames, page);
        if (pos != -1) continue;

        int empty = -1;
        for (int j = 0; j &lt; frames; j++) {
            if (memory[j] == -1) {
                empty = j;
                break;
            }
        }

        if (empty != -1) {
            memory[empty] = page;
            faults++;
            continue;
        }

        // Find page with farthest future use
        int farthest = -1;
        int replace = -1;
        for (int j = 0; j &lt; frames; j++) {
            int k = i + 1;
            for (; k &lt; n; k++) {
                if (ref[k] == memory[j]) {
                    break;
                }
            }
            if (k &gt; farthest) {
                farthest = k;
                replace = j;
            }
        }
        memory[replace] = page;
        faults++;
    }

    free(memory);
    return faults;
}

int lruPage(int ref[], int n, int frames) {
    int *memory = (int *)malloc(frames * sizeof(int));
    int *time = (int *)malloc(frames * sizeof(int));
    memset(memory, -1, frames * sizeof(int));
    int clock = 0;
    int faults = 0;

    for (int i = 0; i &lt; n; i++) {
        int page = ref[i];
        int pos = isInMemory(memory, frames, page);
        if (pos != -1) {
            time[pos] = clock++;
            continue;
        }

        int empty = -1;
        for (int j = 0; j &lt; frames; j++) {
            if (memory[j] == -1) {
                empty = j;
                break;
            }
        }

        if (empty != -1) {
            memory[empty] = page;
            time[empty] = clock++;
            faults++;
            continue;
        }

        // Find min time
        int min_time = INT_MAX;
        int replace = -1;
        for (int j = 0; j &lt; frames; j++) {
            if (time[j] &lt; min_time) {
                min_time = time[j];
                replace = j;
            }
        }
        memory[replace] = page;
        time[replace] = clock++;
        faults++;
    }

    free(memory);
    free(time);
    return faults;
}

int main() {
    int n, frames;
    printf("Enter number of page references: ");
    scanf("%d", &amp;n);
    
    int ref[n];
    printf("Enter the reference string: ");
    for (int i = 0; i &lt; n; i++) {
        scanf("%d", &amp;ref[i]);
    }
    
    printf("Enter number of memory frames: ");
    scanf("%d", &amp;frames);
    
    int optimal_faults = optimalPage(ref, n, frames);
    int lru_faults = lruPage(ref, n, frames);
    
    printf("\nOptimal Page Replacement:\n");
    printf("Total Page Faults: %d\n", optimal_faults);
    
    printf("\nLRU Page Replacement:\n");
    printf("Total Page Faults: %d\n", lru_faults);
    
    return 0;
}